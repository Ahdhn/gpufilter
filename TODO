****************************************************************************
**                                                                        **
**  gpufilter - GPU-Efficient Recursive Filtering and Summed-Area Tables  **
**                                                                        **
**                               TODO File                                **
**                                                                        **
****************************************************************************


    gpufilter is an open software: you can redistribute it and/or
    modify it under the terms of the MIT License as published by the
    Massachusetts Institute of Technology (MIT).

    gpufilter is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the MIT
    License for more details.

    You should have received a copy of the MIT License along with this
    program.  If not, see
    <http://www.opensource.org/licenses/mit-license.php>.

To-do list:

    This to-do list is based on running the CUDA kernel on a nVidia
    GeForce 480 GTX graphics card.

    ( ) Algorithm 4_2 is computing slightly differently values than
        the CPU function r() second-order version (cf. in
        example_r4.cc).  In alg4_* functions, the kernel to compute
        stages 2 and 3 is shared to also compute stages 5 and 6, and
        maybe there is a problem on one of these steps.  Algorithm 4_2
        kernels still use the old definitions of Linf, Minf and Ninf
        defined in the up_constants_coefficients2 function.  The two
        examples, ex7 and ex8, run with maximum error e-02 since both
        depend on algorithm 4_2 to run properly.  The gaussian filter
        running in the GPU also produces slightly different results
        than the same filter running in the CPU, since it depends on
        algorithms 5_1 and 4_2.

    ( ) Algorithm 5_1 stage 4 and 5 kernel function is spilling
        registers to local memory:

ptxas info    : Compiling entry function '_ZN9gpufilter13alg5_stage4_5EPfS0_PKfS2_' for 'sm_20'
ptxas info    : Function properties for _ZN9gpufilter13alg5_stage4_5EPfS0_PKfS2_
    8 bytes stack frame, 8 bytes spill stores, 24 bytes spill loads
ptxas info    : Used 24 registers, 2592+0 bytes smem, 64 bytes cmem[0], 620 bytes cmem[2]

        This is happening because 8 warps per block and 5 blocks in
        the SM overflows the number of required registers by the
        kernel.  To fix the spilling, the number of resident blocks
        could be reduced from 5 to 4 (in the launch-bounds qualifier)
        zeroing the spilling but impacting on performance.  The
        performance is reduced by 2% when running example ex6 (cf. in
        example_r3.cc).  It maybe possible to reduce the register
        count on the alg5_stage4_5 function in a way to remain with 5
        resident blocks (or even increasing to 6) without spilling.
